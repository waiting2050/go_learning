# 全局ID生成器

全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：

```mermaid
graph LR
    A[全局唯一ID] --> B[唯一性]
    A --> C[高可用]
    A --> D[高性能]
    A --> E[递增性]
    A --> F[安全性]
```

---

## 基于Redis的安全ID结构

为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：

### ID的组成部分
| 部分 | 大小 | 说明 |
| --- | --- | --- |
| 符号位 | 1bit | 永远为0 |
| 时间戳 | 31bit | 以秒为单位，可以使用69年 |
| 序列号 | 32bit | 秒内的计数器，支持每秒产生2^32个不同ID |

### 二进制结构示意
```
0 - 00000000 00000000 00000000 00000000 - 00000000 00000000 00000000 00000000
↑           ↑                             ↑
符号位      时间戳(31bit)                 序列号(32bit)
```

# 超卖问题与锁机制

## 超卖问题的产生
多线程并发执行“查询库存→判断库存→扣减库存”流程时，会出现库存超卖的线程安全问题：

![超卖问题](images/超卖问题.png)

---

## 常见解决方案：加锁

### 悲观锁
- **核心思想**：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。
- **常见实现**：`Synchronized`、`Lock` 等。

### 乐观锁
- **核心思想**：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。
- **处理逻辑**：
  - 如果没有修改则认为是安全的，自己才更新数据。
  - 如果已经被其它线程修改说明发生了安全问题，此时可以重试或抛出异常。

---

## 乐观锁的常见实现方式

### CAS法（Compare And Swap）
通过在更新时对比“查询时的库存值”和“当前数据库的库存值”，来判断数据是否被修改：

1.  **线程1** 查询库存为 `1`，执行扣减：
    ```sql
    UPDATE stock SET stock = stock - 1 WHERE id = 10 AND stock = 1;
    ```
    → 条件成立，扣减成功，库存变为 `0`。

2.  **线程2** 同样查询库存为 `1`，执行相同SQL：
    ```sql
    UPDATE stock SET stock = stock - 1 WHERE id = 10 AND stock = 1;
    ```
    → 此时数据库库存已为 `0`，条件不成立，更新失败，避免超卖。

> 这里可以改成看stock是否>0，因为如果看stock是否与上一次查询一致的话可能出现同时100次尝试实际一次成功的情况

```mermaid
sequenceDiagram
    participant 线程1
    participant 线程2
    participant DB

    线程1->>DB: 1. 查询库存（id=10）→ stock=1
    线程2->>DB: 1. 查询库存（id=10）→ stock=1
    线程1->>DB: 2. UPDATE stock SET stock=0 WHERE id=10 AND stock=1
    DB-->>线程1: 更新成功（影响1行）
    线程2->>DB: 2. UPDATE stock SET stock=0 WHERE id=10 AND stock=1
    DB-->>线程2: 更新失败（影响0行）
```

# 分布式锁

## 什么是分布式锁
分布式锁是满足分布式系统或集群模式下，**多进程可见并且互斥**的锁。

它的核心特性包括：
- **多进程可见**：不同JVM、不同机器上的进程都能感知到锁的状态
- **互斥**：同一时间只有一个进程能持有锁
- **高可用**：锁服务本身要具备高可用性，避免单点故障
- **高性能**：加锁、解锁的性能开销要小
- **安全性**：避免死锁，确保锁能被正确释放

---

## 分布式锁的工作流程
在分布式场景下，多线程/多进程通过竞争同一把锁来保证操作的串行执行：

```mermaid
sequenceDiagram
    participant JVM1_线程1
    participant JVM1_线程2
    participant JVM2_线程3
    participant JVM2_线程4
    participant 锁监视器

    JVM1_线程1->>锁监视器: 获取互斥锁
    锁监视器-->>JVM1_线程1: 获取成功 ✅
    JVM1_线程2->>锁监视器: 获取互斥锁
    锁监视器-->>JVM1_线程2: 获取失败 ❌，等待锁释放
    JVM2_线程3->>锁监视器: 获取互斥锁
    锁监视器-->>JVM2_线程3: 获取失败 ❌，等待锁释放
    JVM2_线程4->>锁监视器: 获取互斥锁
    锁监视器-->>JVM2_线程4: 获取失败 ❌，等待锁释放

    JVM1_线程1->>JVM1_线程1: 1. 查询订单
    JVM1_线程1->>JVM1_线程1: 2. 判断是否存在 → 不存在，插入新订单
    JVM1_线程1->>锁监视器: 3. 释放锁

    JVM2_线程3->>锁监视器: 获取互斥锁
    锁监视器-->>JVM2_线程3: 获取成功 ✅
    JVM2_线程3->>JVM2_线程3: 1. 查询订单
    JVM2_线程3->>JVM2_线程3: 2. 判断是否存在 → 已存在，报错
```

---

## 分布式锁的常见实现方式
| 特性 | MySQL | Redis | Zookeeper |
| --- | --- | --- | --- |
| **互斥** | 利用MySQL本身的互斥锁机制 | 利用`SETNX`等互斥命令 | 利用节点的唯一性和有序性实现互斥 |
| **高可用** | 好 | 好 | 好 |
| **高性能** | 一般 | 好 | 一般 |
| **安全性** | 断开连接，自动释放锁 | 利用锁超时时间，到期释放 | 临时节点，断开连接自动释放 |

### 基于Redis的分布式锁（方案一）

#### 核心方法
实现Redis分布式锁，需要实现两个基本方法：

##### 1. 获取锁
- **核心要求**：
  - **互斥**：确保同一时间只有一个线程能获取锁
  - **非阻塞**：尝试一次，成功返回`true`，失败返回`false`
- **命令实现**：
  ```redis
  # 添加锁，NX是互斥、EX是设置超时时间
  SET lock thread1 NX EX 10
  ```
  - `NX`：仅当key不存在时才设置，保证互斥
  - `EX 10`：设置key的过期时间为10秒，防止死锁

---

##### 2. 释放锁
- **核心要求**：
  - **手动释放**：业务执行完成后主动删除锁
  - **超时释放**：获取锁时添加超时时间，避免服务宕机导致死锁
- **命令实现**：
  ```redis
  # 释放锁，删除即可
  DEL key
  ```

> 这样会有一个问题：如果业务执行时间超过了锁的超时时间，那么就会导致锁被自动释放，但是业务还没有执行完，这就会导致别的进程也拿到锁，此时业务完成主动释放的是别的进程的锁。
>> 如何防止释放别人的锁？可以通过加一个标识（比如UUID），在释放锁时判断是否是当前线程的锁。但是这样依旧存在问题，就是有两个进程都发起了请求。

---

#### 执行流程
```mermaid
flowchart LR
    A[开始] --> B[尝试获取锁]
    B -->|结果: nil| C[获取锁失败]
    B -->|结果: ok| D[获取锁成功]
    D --> E[执行业务]
    E --> F[释放锁]
    E -->|业务超时/服务宕机| G[自动释放锁]
```

