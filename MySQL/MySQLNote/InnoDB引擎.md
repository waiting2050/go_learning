# 逻辑存储结构

MySQL InnoDB 存储引擎将数据划分为多个层级进行管理，从宏观到微观依次为：**表空间 -> 段 -> 区 -> 页 -> 行**。

### 1. 表空间 (Tablespace)

* **定义**：通常对应磁盘上的 `.ibd` 文件。
* **关系**：一个 MySQL 实例可以对应多个表空间。
* **用途**：用于存储记录、索引等核心数据。

### 2. 段 (Segment)

* **分类**：主要分为**数据段**（Leaf node segment）、**索引段**（Non-leaf node segment）和**回滚段**（Rollback segment）。
* **特点**：InnoDB 是索引组织表，数据段即 B+ 树的叶子节点，索引段即 B+ 树的非叶子节点。
* **管理**：段用来管理多个 **Extent（区）**。

### 3. 区 (Extent)

* **定义**：表空间的单元结构。
* **大小**：每个区的固定大小为 **1M**。
* **结构**：在默认情况下，InnoDB 页大小为 **16K**，因此一个区中共有 **64个连续的页**。

### 4. 页 (Page)

* **定义**：是 InnoDB 存储引擎**磁盘管理的最小单元**。
* **大小**：默认大小为 **16KB**。
* **优化**：为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。

### 5. 行 (Row)

* **定义**：InnoDB 存储引擎的数据是按行进行存放的。
* **核心隐藏列**：
* **Trx_id**：每次对某条记录进行改动时，都会把对应的事务 ID 赋值给 `trx_id` 隐藏列。
* **Roll_pointer**：回滚指针。每次对某条记录进行改动时，都会把旧的版本写入到 `undo` 日志中，该隐藏列相当于一个指针，可以通过它找到该记录修改前的信息。

# 架构 - 内存架构 (In-Memory Structures)

![InnoDB架构图](markdown-images/InnoDB架构图.png)

InnoDB 内存架构主要由以下四个核心部分组成：**Buffer Pool**、**Change Buffer**、**Adaptive Hash Index** 和 **Log Buffer**。

## 1. Buffer Pool (缓冲池)

缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据。

* **核心逻辑**：在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷到磁盘，从而减少磁盘 IO，加快处理速度。
* **管理单位**：缓冲池以 **Page (页)** 为单位，底层采用链表数据结构管理 Page。
* **Page 的三种状态**：
* **free page**：空闲 page，未使用。
* **clean page**：被使用 page，数据没有被修改过。
* **dirty page**：脏页，数据被修改过，池中数据与磁盘数据不一致。



---

## 2. Change Buffer (更改缓冲区)

针对**非唯一二级索引页**的操作优化。

* **工作原理**：在执行 DML 语句时，如果这些数据 Page 没有在 Buffer Pool 中，不会直接操作磁盘，而是将数据变更存在 `Change Buffer` 中。
* **合并时机**：在未来数据被读取时，再将数据合并恢复到 Buffer Pool 中，随后将合并后的数据刷新到磁盘。
* **意义**：二级索引插入通常是随机的，有了 Change Buffer 可以在缓冲池中进行合并处理，极大地减少随机磁盘 IO。

---

## 3. Adaptive Hash Index (自适应哈希索引)

用于优化对 Buffer Pool 数据的查询效率。

* **机制**：InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到建立哈希索引可以提升速度，则自动建立哈希索引。
* **特点**：无需人工干预，是系统根据情况自动完成的。
* **相关参数**：`adaptive_hash_index`。

---

## 4. Log Buffer (日志缓冲区)

用来保存要写入到磁盘中的日志数据（如 redo log、undo log）。

* **参数与设置**：
* `innodb_log_buffer_size`：定义缓冲区大小，默认 **16MB**。
* `innodb_flush_log_at_trx_commit`：控制日志刷新到磁盘的时机。


* **刷新时机策略**：
* **1**：日志在每次事务提交时写入并刷新到磁盘（安全性最高）。
* **0**：每秒将日志写入并刷新到磁盘一次。
* **2**：日志在每次事务提交后写入，并每秒刷新到磁盘一次。

# 架构 - 磁盘结构 (On-Disk Structures)

InnoDB 的磁盘结构主要由多种表空间（Tablespaces）、缓冲区文件和日志文件组成。

## 1. 表空间 (Tablespaces)

### 系统表空间 (System Tablespace)

* **定义**：是更改缓冲区（Change Buffer）的存储区域。
* **内容**：如果表是在系统表空间而非独立表文件或通用表空间中创建的，它也可能包含表和索引数据。
* **历史版本**：在 MySQL 5.x 版本中，还包含 InnoDB 数据字典、undo log 等。
* **参数**：`innodb_data_file_path`。

### 每表文件表空间 (File-Per-Table Tablespaces)

* **定义**：每个表的独立表空间包含单个 InnoDB 表的数据和索引。
* **存储**：存储在文件系统上的单个数据文件中。
* **参数**：`innodb_file_per_table`。

### 通用表空间 (General Tablespaces)

* **定义**：需要通过 `CREATE TABLESPACE` 语法创建的通用表空间。
* **使用**：在创建表时，可以指定该表空间。
* **语法示例**：
```sql
CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE = engine_name;
CREATE TABLE xxx ... TABLESPACE ts_name;

```



### 撤销表空间 (Undo Tablespaces)

* **定义**：MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小为 16M）。
* **用途**：用于存储 undo log 日志。

### 临时表空间 (Temporary Tablespaces)

* **定义**：InnoDB 使用会话临时表空间和全局临时表空间。
* **用途**：用于存储用户创建的临时表等数据。

---

## 2. 缓冲区文件 (Buffer Files)

### 双写缓冲区文件 (Doublewrite Buffer Files)

* **定义**：InnoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，先将数据页写入双写缓冲区文件中。
* **意义**：便于系统异常时恢复数据。
* **文件名示例**：`#ib_16384_0.dblwr`, `#ib_16384_1.dblwr`。

---

## 3. 日志文件 (Log Files)

### 重做日志 (Redo Log)

* **定义**：用来实现事务的持久性。
* **组成**：由重做日志缓冲（Redo Log Buffer，在内存中）以及重做日志文件（Redo Log，在磁盘中）两部分组成。
* **作用**：当事务提交之后会把所有修改信息都存到该日志中，用于在刷新脏页到磁盘发生错误时进行数据恢复。
* **写入方式**：以循环方式写入重做日志文件，涉及两个文件：`ib_logfile0`, `ib_logfile1`。

# 架构 - 后台线程

InnoDB 存储引擎通过多个后台线程来处理不同的任务，确保内存与磁盘数据的一致性以及系统的高性能。

### 1. Master Thread

* **核心角色**：这是最核心的后台线程。
* **职责**：
* 负责调度其他线程。
* 负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性。
* 包括脏页的刷新、合并插入缓存、undo 页的回收等。



### 2. IO Thread

在 InnoDB 存储引擎中大量使用了 **AIO (Async IO)** 来处理 IO 请求，这可以极大提高数据库性能。IO Thread 主要负责这些 IO 请求的回调。

| 线程类型 | 默认个数 | 职责 |
| --- | --- | --- |
| **Read thread** | 4 | 负责读操作 |
| **Write thread** | 4 | 负责写操作 |
| **Log thread** | 1 | 负责将日志缓冲区刷新到磁盘 |
| **Insert buffer thread** | 1 | 负责将写缓冲区内容刷新到磁盘 |

### 3. Purge Thread

* **主要用途**：用于回收事务已经提交了的 **undo log**。
* **机制**：在事务提交之后，undo log 可能不再需要了，就由该线程负责回收。

### 4. Page Cleaner Thread

* **职责**：协助 Master Thread 刷新脏页到磁盘的线程。
* **意义**：它可以减轻 Master Thread 的工作压力，减少系统阻塞。

# 事务原理

## 1. 事务 (Transaction)

事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

## 2. 特性 (ACID)

数据库事务具有四个核心特性：

* **原子性 (Atomicity)**：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
* **一致性 (Consistency)**：事务完成时，必须使所有的数据都保持一致状态。
* **隔离性 (Isolation)**：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
* **持久性 (Durability)**：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

# 事务原理 - redo log

## 1. 概述

**redo log（重做日志）** 记录的是事务提交时数据页的物理修改情况，主要用来实现事务的**持久性**。

## 2. 组成部分

该日志文件由两部分组成：

* **重做日志缓冲 (redo log buffer)**：位于内存中。
* **重做日志文件 (redo log file)**：位于磁盘中。

## 3. 工作原理

当事务提交之后，系统会把所有修改信息都存到该日志文件中。

* **核心用途**：用于在刷新脏页到磁盘发生错误时，进行数据恢复使用。
* **设计思想**：通过将随机的磁盘 IO 转换为顺序的日志写入，保证了即使数据库宕机，已提交的事务也不会丢失。

# 事务原理 - undo log

## 1. 概述

**undo log（回滚日志）** 主要用于记录数据被修改前的信息，其作用包含两个核心方面：提供**回滚**支持和 **MVCC（多版本并发控制）**。它确保了事务的**原子性**。

## 2. 逻辑日志特性

`undo log` 与记录物理修改的 `redo log` 不同，它属于**逻辑日志**：

* 当执行 `delete` 一条记录时，`undo log` 中会记录一条对应的 `insert` 记录。
* 反之亦然，当执行 `update` 一条记录时，它记录一条对应相反的 `update` 记录。
* **回滚机制**：当执行 `rollback` 时，系统可以从 `undo log` 中的逻辑记录读取到相应的内容并进行回滚。

## 3. 销毁与存储

* **销毁时机**：`undo log` 在事务执行时产生。事务提交时，并不会立即删除 `undo log`，因为这些日志可能还用于 MVCC。
* **存储方式**：`undo log` 采用**段（Segment）**的方式进行管理和记录。
* **存储位置**：存放于回滚段（Rollback Segment）中，内部包含 1024 个 `undo log segment`。

# MVCC - 基本概念

## 1. 当前读 (Current Read)

读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

* **常见操作**：
* `select ... lock in share mode` (共享锁)
* `select ... for update`
* `update`
* `insert`
* `delete` (排他锁)



## 2. 快照读 (Snapshot Read)

简单的 `select` (不加锁) 就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

* **不同隔离级别下的表现**：
* **Read Committed**：每次 `select`，都生成一个快照读。
* **Repeatable Read**：开启事务后第一个 `select` 语句才是快照读的地方。
* **Serializable**：快照读会退化为当前读。



## 3. MVCC

* **全称**：Multi-Version Concurrency Control，即多版本并发控制。
* **定义**：指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。
* **实现依赖**：MVCC 的具体实现，还需要依赖于数据库记录中的**三个隐藏字段**、**undo log 日志**、以及 **readView**。

# MVCC - 实现原理

## 记录中的隐藏字段

在 InnoDB 存储引擎中，每行记录除了自定义的列外，数据库还会隐式地为每行添加三个隐藏字段：

| 隐藏字段 | 含义 |
| --- | --- |
| **DB_TRX_ID** | **最近修改事务 ID**：记录插入这条记录或最后一次修改该记录的事务 ID。 |
| **DB_ROLL_PTR** | **回滚指针**：指向这条记录的上一个版本，用于配合 `undo log`，指向上一个版本。 |
| **DB_ROW_ID** | **隐藏主键**：如果表结构没有指定主键，将会生成该隐藏字段。 |

---

### 字段协作简述

* **DB_TRX_ID** 帮助系统判断当前记录版本是由哪个事务产生的。
* **DB_ROLL_PTR** 是实现 **版本链** 的关键，它像链表指针一样将 `undo log` 中旧版本的数据串联起来。
* 当事务需要读取数据时，会根据 **ReadView** 的规则，顺着 **DB_ROLL_PTR** 找到自己可见的那个版本。

## undo log 版本链

当不同事务或相同事务对同一条记录进行修改时，会导致该记录的 `undolog` 生成一个**记录版本链表**。

### 1. 结构特点

* **链表头部**：存放的是最新的旧记录。
* **链表尾部**：存放的是最早的旧记录。
* **关联方式**：通过每行记录中的隐藏字段 `DB_ROLL_PTR`（回滚指针）串联起来。

### 2. 执行流程示例

根据图中的事务演变过程，展示了 `id=30` 的记录如何形成版本链：

| 动作顺序 | 事务 ID | 执行操作 | 记录状态 (age, name) | undo log 状态 |
| --- | --- | --- | --- | --- |
| 1 | 事务 2 | 修改 `id=30` 记录，`age` 改为 3 | (3, A30) | 生成地址为 `0x00001` 的原始记录快照 |
| 2 | 事务 3 | 修改 `id=30` 记录，`name` 改为 A3 | (3, A3) | 生成地址为 `0x00002` 的快照，指向 `0x00001` |
| 3 | 事务 4 | 修改 `id=30` 记录，`age` 改为 10 | (10, A3) | 生成地址为 `0x00003` 的快照，指向 `0x00002` |

### 3. 核心意义

这种版本链机制是 **MVCC** 实现“快照读”的基础。当一个事务发起查询时，它会根据自身的 **ReadView** 规则，顺着这条版本链从头向后寻找自己“可见”的那一条历史记录。

# MVCC 核心实现：ReadView 详解

**ReadView** 是快照读（Snapshot Read）执行时，底层用来判断“哪个版本的数据我能看，哪个我不能看”的依据。它记录并维护了系统当前活跃（即还没提交）的事务 ID 列表。

## 1. ReadView 的四个核心参数

在执行查询的一瞬间，MySQL 会捕捉以下四个关键信息：

| 字段 | 含义 | 作用 |
| --- | --- | --- |
| **`m_ids`** | **当前活跃事务 ID 集合** | 记录此时此刻所有**开启了但还没提交**的事务。 |
| **`min_trx_id`** | **最小活跃事务 ID** | `m_ids` 中最小的值。 |
| **`max_trx_id`** | **预分配事务 ID** | 当前系统最大事务 ID + 1（即下一个开启的事务 ID）。 |
| **`creator_trx_id`** | **创建者事务 ID** | 当前执行查询的这个事务自己的 ID。 |

---

## 2. 版本链数据访问规则（可见性算法）

当事务读取版本链中的某条记录时，会对比该记录的事务 ID（简称 `trx_id`）与 ReadView 的关系：

* **规则 ①：`trx_id == creator_trx_id`**
* **结论**：**可以访问**。
* **理由**：该版本就是当前事务自己修改的。


* **规则 ②：`trx_id < min_trx_id`**
* **结论**：**可以访问**。
* **理由**：该事务在快照生成前就已提交，属于历史已存在数据。


* **规则 ③：`trx_id > max_trx_id`**
* **结论**：**不可访问**。
* **理由**：该事务是在快照生成之后才开启的，属于“未来的数据”。


* **规则 ④：`min_trx_id <= trx_id <= max_trx_id`**
* **判断**：看 `trx_id` 是否在 `m_ids` 集合中。
* **如果在**：说明快照生成时该事务还没提交，**不可访问**。
* **如果不在**：说明快照生成时该事务已经提交，**可以访问**。



---

## 3. 隔离级别对 ReadView 的影响

这两张图展示了 MVCC 如何实现不同的隔离级别：

* **Read Committed (RC)**：
* **策略**：事务中**每次**执行 `select` 都会重新生成一个新的 ReadView。
* **结果**：只要别人提交了，你下一次查询就能实时看到最新结果。


* **Repeatable Read (RR)**：
* **策略**：仅在事务中**第一次**执行 `select` 时生成 ReadView，后续一直复用。
* **结果**：即使别人中途提交了，由于你的“活跃事务名单”没更新，你依然只能看到事务开始时的样子，从而实现“可重复读”。

# MVCC - 实现原理 (RC 级别解析)

![RC级别MVCC原理分析](markdown-images/RC级别MVCC原理分析.png)

## 1. 核心流程演练

该图展示了在 **Read Committed (RC)** 隔离级别下，多个并发事务对同一条记录（`id=30`）进行修改并查询时的 ReadView 变化过程。

### 事务背景

* **版本链状态**：记录经历了三次修改（事务 2、事务 3、事务 4），产生了一个包含三个历史版本的 `undo log` 链。
* **当前读状态**：记录最新的物理状态为 `(30, 10, A3)`，其 `DB_TRX_ID` 为 4。

---

## 2. 两次查询的 ReadView 对比

在 **RC** 级别下，**每一次**快照读都会生成一个新的 ReadView。

### 第一次查询（事务 5 发起）

* **时机**：处于事务 3 提交后，但事务 2 和事务 4 仍在活跃中。
* **ReadView 参数**：
* `m_ids`: `{3, 4, 5}` (当前活跃事务)
* `min_trx_id`: `3`
* `max_trx_id`: `6`
* `creator_trx_id`: `5`


* **匹配过程**：
1. 检查最新版本 (trx_id=4)：在 `m_ids` 中，不可见。
2. 顺着链找上一个版本 (trx_id=3)：在 `m_ids` 中，不可见。
3. 找再上一个版本 (trx_id=2)：小于 `min_trx_id`，可见。


* **结果**：读取到事务 2 提交后的版本。

### 第二次查询（事务 5 发起）

* **时机**：处于事务 3 提交之后再次查询。
* **ReadView 参数**（更新）：
* `m_ids`: `{4, 5}` (事务 3 已提交，从集合中移除)
* `min_trx_id`: `4`


* **匹配过程**：
1. 检查版本 (trx_id=3)：此时 `trx_id < min_trx_id` 成立，说明已提交。


* **结果**：读取到事务 3 修改后的版本，实现了“读已提交”。

---

## 3. 访问规则复习

* **规则 ①**：`trx_id == creator_trx_id`  可见。
* **规则 ②**：`trx_id < min_trx_id`  可见（说明已提交）。
* **规则 ③**：`trx_id > max_trx_id`  不可见（说明是后开启的）。
* **规则 ④**：`min_trx_id <= trx_id <= max_trx_id`  若不在 `m_ids` 中，则可见。

# MVCC - 实现原理 (RR 级别解析)

![RR级别MVCC原理分析](markdown-images/RR级别MVCC原理分析.png)



## 1. 核心机制：ReadView 复用

在 **Repeatable Read (RR)** 隔离级别下，MVCC 的表现与 RC 级别有本质区别：

* **生成时机**：仅在事务中**第一次**执行快照读（`SELECT`）时生成一个 ReadView。
* **复用规则**：在该事务后续的所有快照读操作中，都会**复用**第一次生成的那个 ReadView。

## 2. 案例分析：事务 5 的查询过程

图中展示了事务 5 在整个生命周期内两次查询 `id=30` 记录的情况：

### 第一次快照读

* **操作**：事务 5 执行第一次查询。
* **生成 ReadView**：
* `m_ids`: `{3, 4, 5}`（此时事务 3、4、5 均未提交）。
* `min_trx_id`: `3`。
* `max_trx_id`: `6`。
* `creator_trx_id`: `5`。


* **结果**：根据可见性算法，由于事务 3 和 4 都在 `m_ids` 中，它们修改的版本不可见，事务 5 会读取到事务 2 提交后的历史版本。

### 第二次快照读

* **操作**：在事务 3 和事务 4 先后提交后，事务 5 再次执行查询。
* **ReadView 状态**：由于是 RR 级别，事务 5 **直接复用**第一次生成的 ReadView（`m_ids` 依然保持 `{3, 4, 5}`），而不是重新生成。
* **结果**：尽管事务 3 和 4 已经在物理上提交了，但在事务 5 的 ReadView 眼里，它们依然属于“活跃事务”。因此，事务 5 依然无法看到事务 3 和 4 的新修改，读取到的内容与第一次完全相同。

## 3. RR 级别的意义

这种“复用 ReadView”的机制确保了：

* **可重复读**：只要在同一个事务内，多次读取同一条记录的结果永远保持一致，不受其他并发事务提交的影响。
* **隔离性**：有效地屏蔽了其他事务在当前事务运行期间所做的变更。

