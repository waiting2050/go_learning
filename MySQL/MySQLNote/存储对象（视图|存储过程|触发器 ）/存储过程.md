# 基本语法

## 1. 介绍

存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合。

* **简化开发**：调用存储过程可以简化应用开发人员的很多工作。
* **减少传输**：减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
* **本质**：思想上很简单，就是数据库 SQL 语言层面的代码**封装与重用**。

## 2. 特点

* **封装，复用**：将复杂的业务逻辑封装起来，方便多次调用。
* **可以接收参数，也可以返回数据**：支持输入参数（IN）和输出参数（OUT/INOUT），增强了灵活性。
* **减少网络交互，效率提升**：因为多条 SQL 语句在一次调用中完成，显著降低了客户端与服务器之间的网络往返开销。

## 存储过程 - 基本语法

### 1. 创建 (Create)

使用 `CREATE PROCEDURE` 语句来定义存储过程，其核心逻辑写在 `BEGIN ... END` 块之间。

```sql
CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])
BEGIN
    -- SQL 语句
END ;

```

> **注意**：在命令行中执行创建语句时，通常需要先通过关键字 `delimiter` 指定新的 SQL 语句结束符，以防止内部的分号导致语句提前结束。

### 2. 调用 (Call)

使用 `CALL` 关键字来执行已经定义好的存储过程。

```sql
CALL 名称 ([ 参数 ]);

```

### 3. 查看 (View)

* **查询状态信息**：可以从系统表 `INFORMATION_SCHEMA.ROUTINES` 中查询指定数据库的存储过程详情。
```sql
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'; 

```


* **查询定义语句**：查看创建该存储过程的具体 SQL 源码。
```sql
SHOW CREATE PROCEDURE 存储过程名称;

```



### 4. 删除 (Drop)

使用 `DROP PROCEDURE` 语句删除指定的存储过程。

```sql
DROP PROCEDURE [ IF EXISTS ] 存储过程名称;

```


# 存储过程 - 变量

## 1. 系统变量

**系统变量** 是由 MySQL 服务器提供，不是用户定义的，属于服务器层面。系统变量分为 **全局变量 (GLOBAL)** 和 **会话变量 (SESSION)**。

### 2. 查看系统变量

可以通过以下方式查看所有或指定的系统变量：

* **查看所有系统变量**：
```sql
SHOW [ SESSION | GLOBAL ] VARIABLES ;

```


* **通过 LIKE 模糊匹配方式查找变量**：
```sql
SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......' ;

```


* **查看指定变量的值**：
```sql
SELECT @@[ SESSION | GLOBAL ] 系统变量名 ;

```



### 3. 设置系统变量

可以通过 `SET` 指令为变量赋值：

* **方式一**：
```sql
SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;

```


* **方式二**：
```sql
SET @@[ SESSION | GLOBAL ] 系统变量名 = 值 ;

```



---

### ⚠️ 注意事项：

1. **默认级别**：如果没有指定 `SESSION` 或 `GLOBAL`，默认是 **SESSION（会话变量）**。
2. **时效性**：MySQL 服务重新启动之后，所设置的全局参数会**失效**。
3. **永久生效**：要想让设置永久有效，需要在 MySQL 的配置文件 `/etc/my.cnf` 中进行配置。

## 2. 用户定义变量

**用户定义变量** 是用户根据需要自己定义的变量。用户变量不用提前声明，在用的时候直接用 “`@变量名`” 使用就可以。其作用域为当前连接。

### 赋值

可以通过以下几种方式为用户定义变量赋值：

* **使用 SET 语句赋值**：
```sql
SET @var_name = expr [, @var_name = expr] ... ;
SET @var_name := expr [, @var_name := expr] ... ;

```


* **使用 SELECT 语句赋值**：
```sql
SELECT @var_name := expr [, @var_name := expr] ... ;
SELECT 字段名 INTO @var_name FROM 表名;

```



### 使用

通过 `SELECT` 语句来查看或使用变量的值：

```sql
SELECT @var_name ;

```

---

### ⚠️ 注意事项：

* 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 `NULL`。
* 赋值时使用 `:=` 是 MySQL 中推荐的赋值方式，用以区分比较操作符 `=`。


## 3. 局部变量

**局部变量** 是根据需要定义的在局部生效的变量。在访问局部变量之前，需要使用 `DECLARE` 语句进行声明。

### 特点

* **生命周期**：局部变量的范围是在其内声明的 `BEGIN ... END` 块。
* **用途**：可用作存储过程内的局部变量和输入参数。

### 声明

使用 `DECLARE` 关键字声明变量，并指定其类型：

```sql
DECLARE 变量名 变量类型 [DEFAULT ... ] ;

```

* **变量类型**：即数据库字段类型，例如 `INT`、`BIGINT`、`CHAR`、`VARCHAR`、`DATE`、`TIME` 等。

### 赋值

局部变量的赋值方式与用户定义变量类似，通常在 `BEGIN ... END` 块内进行：

```sql
SET 变量名 = 值 ;
SET 变量名 := 值 ;
SELECT 字段名 INTO 变量名 FROM 表名；

```

---

## 💡 变量对比小结

* **系统变量**：服务器级的，影响整个服务器或当前连接。
* **用户定义变量**：当前连接（会话）级有效，以 `@` 开头。
* **局部变量**：仅在存储过程的 `BEGIN ... END` 块内有效，必须先声明再使用。


---

# if 流程控制

## 1. 介绍

在存储过程中，可以使用 `if` 语句来进行条件判断，根据不同的条件执行不同的 SQL 逻辑。这使得存储过程能够处理复杂的业务分支，真正具备了“编程”的能力。

## 2. 语法结构

```sql
IF 条件1 THEN
    .....
[ELSEIF 条件2 THEN]    -- 可选
    .....
[ELSE]                -- 可选
    .....
END IF;

```

### 语法详解

* **IF ... THEN**：如果“条件1”成立，则执行紧随其后的代码块。
* **ELSEIF**：可选部分。如果前面的条件都不成立，但“条件2”成立，则执行对应的代码块。
* **ELSE**：可选部分。当以上所有条件都不满足时，执行该默认分支的代码。
* **END IF**：必须以 `END IF;` 结束判断块。

---

### 💡 实际应用场景示例

假设我们要根据学生的分数来判定等级：

```sql
CREATE PROCEDURE get_level(IN score INT)
BEGIN
    IF score >= 85 THEN
        SELECT '优秀';
    ELSEIF score >= 60 THEN
        SELECT '及格';
    ELSE
        SELECT '不及格';
    END IF;
END;

```

根据您上传的最后一张图片，以下是关于 **存储过程 - 参数（IN/OUT/INOUT）** 的 Markdown 笔记：

---

# 参数

## 1. 参数类型

存储过程支持多种类型的参数，用于在调用者和过程之间传递数据。

| 类型 | 含义 | 备注 |
| --- | --- | --- |
| **IN** | 该类参数作为输入，也就是需要调用时传入值 | **默认类型** |
| **OUT** | 该类参数作为输出，也就是该参数可以作为返回值 | - |
| **INOUT** | 既可以作为输入参数，也可以作为输出参数 | - |

## 2. 用法示例

在创建存储过程时，需要在括号内指定参数的模式、名称和类型：

```sql
CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])
BEGIN
    -- SQL语句
END ;

```

---

### 💡 快速理解

* **IN（进）**：像函数的入参，传进去给存储过程用，但过程内部的修改不会影响外部。
* **OUT（出）**：像函数的返回值，调用时传一个变量进去，过程执行完后，结果会写进这个变量里。
* **INOUT（进且出）**：合二为一，既把初始值传进去，执行完后又把新值带出来。

# case 流程控制

## 1. 语法一

这种语法适用于**等值判断**，类似于编程语言中的 `switch-case` 结构。

```sql
CASE case_value
    WHEN when_value1 THEN statement_list1
    [WHEN when_value2 THEN statement_list2] ...
    [ELSE statement_list]
END CASE;

```

* **case_value**: 表达式或字段名。
* **when_value**: 预期的匹配值。
* **statement_list**: 如果 `case_value` 等于对应的 `when_value`，则执行该处的 SQL 逻辑。

## 2. 语法二

这种语法类似于**多重 if 判断**，可以处理复杂的**范围条件**。

```sql
CASE
    WHEN search_condition1 THEN statement_list1
    [WHEN search_condition2 THEN statement_list2] ...
    [ELSE statement_list]
END CASE;

```

* **search_condition**: 一个返回真或假的布尔表达式（如 `score >= 90`）。
* **statement_list**: 如果搜索条件成立，则执行对应的 SQL 逻辑。

---

### 💡 小贴士

* **默认分支**：如果所有 `WHEN` 都不匹配且没有写 `ELSE`，MySQL 会报错。
* **结束符**：注意在存储过程内使用时，最后必须以 `END CASE;` 结束。

# while 循环

## 1. 介绍

`while` 循环是有条件的循环控制语句。满足预设的条件后，再执行循环体中的 SQL 语句。这与编程语言中的 `while` 逻辑一致：**先判定条件，再执行逻辑**。

## 2. 语法结构

```sql
WHILE 条件 DO
    SQL逻辑...
END WHILE;

```

### 执行逻辑说明

* **先判定条件**：如果条件计算结果为 `true`，则执行 `DO` 之后的 SQL 逻辑。
* **执行逻辑**：执行完内部的 SQL 逻辑后，会再次返回判定条件。
* **退出循环**：如果条件判定为 `false`，则不执行逻辑，直接退出循环。

---

### 💡 示例：计算从 1 加到 n 的总和

```sql
CREATE PROCEDURE sum_while(IN n INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    WHILE n > 0 DO
        SET total := total + n;
        SET n := n - 1;
    END WHILE;
    SELECT total;
END;

```

# repeat 循环

## 1. 介绍

`repeat` 是另一种有条件的循环控制语句。与 `while` 不同的是，`repeat` 属于**后判定条件循环**（类似于编程语言中的 `do-while`），即先执行一次逻辑，再判定是否满足退出条件。

## 2. 语法结构

```sql
REPEAT
    SQL逻辑...
    UNTIL 条件
END REPEAT;

```

### 执行逻辑说明

1. **先执行逻辑**：首先无条件执行一次 `REPEAT` 和 `UNTIL` 之间的 SQL 语句。
2. **判定逻辑是否满足**：执行完逻辑后，检查 `UNTIL` 后的条件。
3. **退出或继续**：
* 如果条件满足（为 `true`），则**退出**循环。
* 如果条件不满足（为 `false`），则**继续**下一次循环。



---

### 💡 `WHILE` 与 `REPEAT` 的本质区别

* **WHILE**：**先判断，再执行**。只有条件成立才会进入循环，可能一次都不执行。
* **REPEAT**：**先执行，再判断**。无论条件如何，循环体**至少会执行一次**。

# loop 循环

## 1. 介绍

`LOOP` 可以实现简单的循环。如果在 SQL 逻辑中不增加退出循环的条件，可以用其来实现简单的死循环。为了灵活控制循环，`LOOP` 通常配合以下两个语句使用：

* **LEAVE**：配合循环使用，用于**退出循环**（类似于编程语言中的 `break`）。
* **ITERATE**：必须用在循环中，作用是跳过当前循环剩下的语句，**直接进入下一次循环**（类似于编程语言中的 `continue`）。

## 2. 语法结构

### LOOP 循环定义

```sql
[begin_label:] LOOP
    SQL逻辑...
END LOOP [end_label];

```

> **注意**：`label` 是随意的标记名，用于标识循环体，以便 `LEAVE` 或 `ITERATE` 指定操作哪个循环。

### 控制指令

* **退出循环**：
```sql
LEAVE label; -- 退出指定标记的循环体

```


* **跳过本次进入下一次**：
```sql
ITERATE label; -- 直接进入下一次循环

```



---

### 💡 循环控制总结

在存储过程中，你可以根据业务需求灵活选择：

1. **WHILE**：最常用的先判断后执行循环。
2. **REPEAT**：至少执行一次的后判断循环。
3. **LOOP**：最灵活的无限循环，手动通过 `LEAVE` 停下来。


# 游标

## 1. 介绍

**游标（CURSOR）** 是用来存储查询结果集的数据类型。在存储过程和函数中，可以使用游标对结果集进行循环处理。游标的使用通常包括声明、打开、获取记录和关闭四个步骤。

## 2. 语法结构

### 2.1 声明游标

使用 `DECLARE` 关键字定义游标，并绑定到一个具体的查询语句上。

```sql
DECLARE 游标名称 CURSOR FOR 查询语句 ;

```

### 2.2 打开游标

在使用游标提取数据前，必须先打开它。

```sql
OPEN 游标名称 ;

```

### 2.3 获取游标记录

将游标当前指向的一行数据提取到指定的变量中。

```sql
FETCH 游标名称 INTO 变量 [, 变量] ;

```

### 2.4 关闭游标

数据处理完成后，应关闭游标以释放系统资源。

```sql
CLOSE 游标名称 ;

```

---

### 💡 为什么需要游标？

普通的 `SELECT` 语句会一次性返回所有结果，而游标允许你**一行一行**地处理数据。它就像一个“指针”，可以在结果集里一条条地往下挪动，配合前面学过的 `LOOP` 循环，可以实现对每一行记录进行复杂的逻辑运算。

# 条件处理程序

## 1. 介绍

**条件处理程序 (Handler)** 可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。它类似于编程语言中的 `try-catch` 异常处理机制，常用于捕获游标遍历结束后的特定状态，以优雅地退出循环。

## 2. 语法结构

```sql
DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement ;

```

### 参数详解

#### **handler_action (处理动作)**

* **CONTINUE**: 继续执行当前程序。
* **EXIT**: 终止执行当前程序。

#### **condition_value (触发条件)**

* **SQLSTATE sqlstate_value**: 状态码，如 `02000`（常用于表示游标数据已读完）。
* **SQLWARNING**: 所有以 `01` 开头的 `SQLSTATE` 代码的简写。
* **NOT FOUND**: 所有以 `02` 开头的 `SQLSTATE` 代码的简写。
* **SQLEXCEPTION**: 所有没有被 `SQLWARNING` 或 `NOT FOUND` 捕获的 `SQLSTATE` 代码的简写。

---

### 💡 典型应用场景

在使用游标循环读取数据时，当读取到结果集最后一行之后，再次执行 `FETCH` 会触发 `NOT FOUND` 条件。此时可以定义一个处理程序：

```sql
-- 当数据找不到了，就将退出标记变量改为 1，并继续执行后续关闭游标的操作
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

```

# 存储函数

## 1. 介绍

存储函数是有返回值的存储过程，存储函数的参数只能是 `IN` 类型的。

## 2. 语法结构

```sql
CREATE FUNCTION 存储函数名称 ([ 参数列表 ])
RETURNS type [characteristic ...]
BEGIN
    -- SQL语句
    RETURN ...;
END ;

```

## 3. characteristic (特性) 说明

在创建存储函数时，必须指定函数特性，常见的包括：

* **DETERMINISTIC**：确定的。相同的输入参数总是产生相同的结果。
* **NO SQL**：不包含 SQL 语句。
* **READS SQL DATA**：包含读取数据的语句（如 `SELECT`），但不包含写入数据的语句。

---

### 💡 关键点回顾

* **返回值**：存储函数必须使用 `RETURNS` 声明返回类型，并使用 `RETURN` 关键字返回结果。
* **参数限制**：不同于存储过程支持 `OUT` 和 `INOUT`，存储函数的参数默认且只能是输入性质的（`IN`）。

# 触发器 (Trigger)

## 1. 介绍

触发器是与表有关的数据库对象，指在 `insert` / `update` / `delete` 之前（BEFORE）或之后（AFTER），触发并执行触发器中定义的 SQL 语句集合。

* **主要用途**：协助应用在数据库端确保数据的完整性、日志记录、数据校验等操作。
* **别名引用**：使用别名 `OLD` 和 `NEW` 来引用触发器中发生变化的记录内容，这与其他数据库相似。
* **限制**：目前 MySQL 触发器还只支持**行级触发**，不支持语句级触发。

---

## 2. NEW 与 OLD 的具体含义

触发器在不同的操作类型中，`NEW` 和 `OLD` 所代表的数据含义不同：

| 触发器类型 | NEW 和 OLD 的含义 |
| --- | --- |
| **INSERT 型触发器** | **NEW** 表示将要或者已经新增的数据。 |
| **UPDATE 型触发器** | **OLD** 表示修改之前的数据；**NEW** 表示将要或者已经修改后的数据。 |
| **DELETE 型触发器** | **OLD** 表示将要或者已经删除的数据。 |

---

### 💡 核心理解

触发器就像是数据库里的“**自动监视器**”。你不需要手动去调用它，只要你对表做了增、删、改的操作，它就会按照你预设的逻辑自动跑起来。
