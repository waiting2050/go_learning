以下是优化排版后的 Markdown 版本（内容未修改，仅调整格式、加粗重点、优化列表/分隔线等）：


# MySQL 索引知识点总结


## 1. 索引概述

### 介绍
**索引 (Index)** 是帮助 MySQL **高效获取数据** 的 **数据结构 (有序)**。
在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，从而可以在这些结构上实现高级查找算法，这种数据结构就是索引。


### 优缺点对比
| **优势** | **劣势** |
|----------|----------|
| 提高数据检索效率，降低数据库 **IO 成本** | 索引列会 **占用存储空间** |
| 通过索引列排序数据，降低排序成本与 **CPU 消耗** | 降低表的更新速度（`INSERT`/`UPDATE`/`DELETE` 效率下降） |


---


## 2. 索引结构
MySQL 的索引在 **存储引擎层** 实现，不同存储引擎支持的结构不同，主要类型如下：

| **索引结构** | **描述** |
|--------------|----------|
| **B+Tree 索引** | 最常见的索引类型，大部分引擎支持 |
| **Hash 索引** | 底层为哈希表，仅支持精确匹配，不支持范围查询 |
| **R-tree (空间索引)** | MyISAM 特有的索引类型，用于地理空间数据，使用较少 |
| **Full-text (全文索引)** | 基于倒排索引实现文档快速匹配，类似 Lucene/Solr/ES |


---


## 3. 索引结构支持情况
不同存储引擎对索引结构的支持如下：

| **索引** | **InnoDB** | **MyISAM** | **Memory** |
|----------|------------|------------|------------|
| **B+tree 索引** | 支持 | 支持 | 支持 |
| **Hash 索引** | 不支持（但有自适应哈希索引） | 不支持 | 支持 |
| **R-tree 索引** | 不支持 | 支持 | 不支持 |
| **Full-text** | 5.6 版本后支持 | 支持 | 不支持 |


> **注意：** 虽然 InnoDB 不直接支持 Hash 索引，但它具备“自适应哈希索引”的内部优化功能。


---


# MySQL 索引结构深度解析


## 1. 二叉树与红黑树的局限性

### 二叉树 (Binary Tree)
- **缺点**：顺序插入数据时会形成单向链表，查询性能大幅降低。
- **大数据量问题**：数据量较大时树的层级过深，检索速度慢。


### 红黑树 (Red-Black Tree)
- **特点**：自平衡二叉树，避免退化为链表。
- **缺点**：大数据量下层级依然较深，检索速度相对较慢。


![红黑树和二叉树示意图](markdown-images/红黑树和二叉树示意图.png)


---


## 2. B-Tree（多路平衡查找树）
B-Tree 是专为外部存储设计的多路平衡查找树，可有效降低树的高度。


### 核心概念
- **树的度数 (Max-degree)**：一个节点最多拥有的子节点个数。
- **节点存储**（以 5 阶 B-Tree 为例）：
  - 每个节点最多存储 4 个 key；
  - 每个节点最多拥有 5 个指针。


### 结构示意
- 节点包含 **数据 (Data)** 和 **子节点指针**；
- 所有叶子节点位于同一层。


![B-Tree 示意图1](markdown-images/B-Tree示意图1.png)


### B-Tree 插入示例
插入数据（如 `100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250`）时：
- 当节点 key 数量达到度数上限，节点会 **分裂**；
- 中间元素上移到父节点，保持树的平衡与低高度。


![B-Tree 示意图2](markdown-images/B-Tree示意图2.png)


---


## 3. B+Tree 结构
B+Tree 是 MySQL 索引的核心实现基础，与 B-Tree 的主要区别：
1. **数据位置**：所有数据仅出现在叶子节点，非叶子节点仅存储键值和指针；
2. **叶子连接**：叶子节点形成单向链表（经典 B+Tree 结构）。


![B+Tree 示意图1](markdown-images/B+Tree示意图1.png)
![B+Tree 示意图2](markdown-images/B+Tree示意图2.png)


---


## 4. MySQL 优化的 B+Tree
MySQL 对经典 B+Tree 进一步优化，提升区间访问性能：
- **双向顺序指针**：叶子节点增加相邻节点的链表指针，形成双向循环链表；
- **页/块管理**：数据组织在页/块中，通过双向指针连接，大幅提高范围查询效率。


![B+Tree 示意图](markdown-images/B+Tree(MySQL)示意图.png)


---


# Hash 索引


## 1. 基本原理
哈希索引通过 **Hash 算法** 将键值换算为 **Hash 值**，映射到对应 **槽位** 并存储在 Hash 表中。
- **Hash 冲突**：多个键值映射到同一槽位时，通过 **链表** 解决。


![哈希示意图](markdown-images/哈希示意图.png)


---


## 2. Hash 索引特点
1. **查询限制**：仅支持 **等值比较**（`=`、`in`），不支持范围查询（`between`、`>`、`<` 等）；
2. **排序限制**：无法利用索引完成排序操作；
3. **查询效率**：通常一次检索即可定位数据，效率 **高于 B+Tree 索引**。


---


## 3. 存储引擎支持情况
- **Memory 引擎**：显式支持 Hash 索引；
- **InnoDB 引擎**：具有 **自适应 Hash (Adaptive Hash)** 功能，由存储引擎根据 B+Tree 索引自动构建，用户无法手动干预。


---


# 思考：为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？
通过与其他数据结构对比，B+Tree 在数据库索引场景下优势显著：


### 1. 相对于二叉树 (Binary Tree)
- **层级更少**：二叉树大数据量下层数深、检索慢；B+Tree 作为多路树，层级更少、效率更高；
- **性能稳定**：二叉树顺序插入会退化为链表；B+Tree 始终保持平衡。


### 2. 相对于 B-Tree
- **单页存储容量更大**：B-Tree 非叶子节点存数据，导致单页键值/指针数量少；
- **树的高度更低**：B-Tree 需增加高度存储大量数据，增加磁盘 IO；
- **B+Tree 优势**：非叶子节点仅存索引，树更“矮胖”；叶子节点双向指针大幅提升范围查询效率。


### 3. 相对于 Hash 索引
- **功能更全面**：Hash 索引不支持范围查询与排序；
- **灵活度高**：B+Tree 同时支持范围匹配与排序操作。


# 索引分类

## 1. 常规分类

根据索引的用途和约束，主要分为以下四类：

| 分类 | 含义 | 特点 | 关键字 |
| --- | --- | --- | --- |
| **主键索引** | 针对于表中主键创建的索引 | 默认自动创建，只能有一个 | PRIMARY |
| **唯一索引** | 避免同一个表中某数据列中的值重复 | 可以有多个 | UNIQUE |
| **常规索引** | 快速定位特定数据 | 可以有多个 |  |
| **全文索引** | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个 | FULLTEXT |

---

## 2. InnoDB 存储形式分类

在 InnoDB 存储引擎中，根据索引的 **存储形式**，可以分为以下两种：

| 分类 | 含义 | 特点 |
| --- | --- | --- |
| **聚集索引** (Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| **二级索引** (Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个 |

### 聚集索引选取规则：

* 如果存在主键，**主键索引就是聚集索引**。
* 如果不存在主键，将使用 **第一个唯一 (UNIQUE) 索引** 作为聚集索引。
* 如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 **rowid** 作为隐藏的聚集索引。

![聚集索引和二级索引1](markdown-images/聚集索引和二级索引1.png)
![聚集索引和二级索引2](markdown-images/聚集索引和二级索引2.png)

## 1. InnoDB 主键索引的 B+Tree 高度估算

### 假设条件：

* **数据页大小**：一页的大小通常为 **16k**。
* **单行记录**：假设一行数据大小为 **1k**，一页中可以存储 **16行** 这样的数据。
* **指针开销**：InnoDB 的指针占用 **6个字节** 的空间。
* **主键大小**：主键即使为 `bigint`，占用字节数也仅为 **8个字节**。

### 计算过程：

#### 高度为 2 时：

设  为非叶子节点中主键的数量，则有公式：


* **计算结果**：算出  约为 **1170**。
* **指针数量**：约为 **1171**。
* **总记录数**： 1171(页数) × 16(行数) = **18,736条数据**。

#### 高度为 3 时：

* **总记录数**： 1171 x 1171 x 16 = **21,939,856条数据**。

> **结论**：在 InnoDB 存储引擎中，高度为 3 的 B+Tree 索引即可支撑 **两千万级别** 的数据量存储。

---

## 2. SQL 语句执行效率案例分析

### 案例问题：

以下两条 SQL 语句，哪一个执行效率更高？为什么？

1. `select * from user where id = 10;`
2. `select * from user where name = 'Arm';`

**备注**：`id` 为主键，`name` 字段创建了常规索引。

### 解析：

**第一条语句（根据 ID 查询）执行效率更高。**

* **主键查询**：通过 `id` 查询直接走 **聚集索引**，聚集索引的叶子节点直接保存了完整的行记录数据，查询效率极高。
* **非主键查询**：通过 `name` 查询走的是 **二级索引**。二级索引的叶子节点只保存了对应的主键 ID。在查到 ID 后，还需要回到聚集索引中再次查找以获取完整行数据，这个过程被称为 **“回表查询”**，因此效率相对较低。
