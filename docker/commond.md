### docker run命令中的常见参数
- `-d`：让容器后台运行
- `--name`：给容器命名
- `-e`：环境变量
- `-p`：宿主机端口映射到容器内端口


### 镜像名称结构
格式：`Repository:TAG`
- `Repository`：镜像名
- `TAG`：版本号

# Docker 命令解读文档
## 一、基本介绍
### 1. 核心概念关联
| 操作对象 | 核心命令 | 状态流转 |
|----------|----------|----------|
| 镜像（Image） | docker pull/push/build/save/load/rmi | 本地镜像 ↔ 镜像仓库 |
| 容器（Container） | docker run/start/stop/kill/rm/exec | 运行中 ↔ 已停止 |

### 2. 帮助命令
```bash
# 查看 Docker 版本信息
docker version

# 查看 Docker 系统信息（如镜像数、容器数、内核版本等）
docker info

# 查看指定命令的详细用法（替换 [command] 为具体命令，如 run、pull）
docker [command] --help

# 不输入具体命令，展示所有可用 Docker 命令
docker --help
```

## 二、核心流程：下载→启动→修改→保存→分享
### 任务目标：拉取 Nginx 镜像，修改页面并发布

## 三、镜像操作命令
### 1. 检索镜像（不推荐）
- 命令：`docker search [镜像名]`（如 `docker search nginx`）
- 问题：可能报错 `Error response from daemon: Get "https://index.docker.io/v1/search?q=xxx&n=25": dial tcp ...: connect: connection refused`
- 推荐方式：直接访问 [Docker Hub 官网](https://hub.docker.com/) 搜索镜像（需科学上网）

### 2. 拉取镜像（推荐）
- 语法：`docker pull image[:tag]`（tag 为版本号，不写默认 latest）
- 示例：拉取 Nginx 官方镜像
  ```bash
  docker pull nginx
  ```
- 常见报错：`Error response from daemon: Get "https://registry-1.docker.io/v2/": ...`
- 解决方案：重新配置 Docker 镜像加速器

### 3. 查看本地镜像
- 语法：`docker images [option]`
- 输出字段：镜像名、版本标签、镜像 ID（唯一标识）、创建时间、大小

### 4. 删除镜像
- 语法：`docker rmi [option] image:tag`（或镜像 ID）
- 强制删除所有镜像（慎用）：
  ```bash
  docker rmi -f $(docker images -aq)
  ```

### 5. 镜像保存与加载
#### （1）保存镜像为压缩包
- 语法：`docker save [option] image[:tag] > 保存路径/文件名.tar`
- 示例：
  ```bash
  docker save nginx:latest > ./nginx-backup.tar
  ```

#### （2）从压缩包加载镜像
- 语法：`docker load [option] < 压缩包路径/文件名.tar`
- 用途：迁移镜像到其他服务器，或本地备份恢复

### 6. 镜像提交（自定义镜像）
- 语法：`docker commit [option] 容器ID/容器名 [repository[:tag]]`
- 作用：基于修改后的容器创建新镜像（如修改 Nginx 页面后保存为自定义镜像）

## 四、容器操作命令
### 1. 运行容器
- 语法：`docker run [option] image[:tag] [command] [arg...]`
- 核心参数说明：
  - `-d`：后台运行容器
  - `--name`：指定容器名称（如 `--name my-nginx`）
  - `-p`：端口映射（如 `-p 80:80`，宿主机端口:容器内端口）
  - `-it`：交互式终端（进入容器时使用）
- 示例：启动 Nginx 容器并映射 80 端口
  ```bash
  docker run -d --name my-nginx -p 80:80 nginx
  ```
- 注意：不写 tag 时默认使用 latest 版本；command 和 arg 为容器默认启动命令，一般无需手动指定
- 终止运行：`ctrl + c`（仅前台运行时有效）

### 2. 停止容器
#### （1）正常停止
- 语法：`docker stop 容器ID/容器名`
- 示例：
  ```bash
  docker stop my-nginx
  ```

#### （2）强制停止（适用于容器无响应）
- 语法：`docker kill 容器ID/容器名`
- 说明：直接发送 SIGKILL 信号，不给容器内进程清理机会，快速终止

### 3. 启动/重启容器
#### （1）启动已停止的容器
- 语法：`docker start 容器ID/容器名`

#### （2）重启容器（运行中→重启，已停止→启动）
- 语法：`docker restart 容器ID/容器名`

### 4. 查看容器状态
#### （1）查看运行中的容器
- 语法：`docker ps [option]`
- 输出字段：容器 ID、镜像名、默认命令、创建时间、启动状态（Up 为运行中）、占用端口、容器名
- 关键参数：`-a` 查看所有容器（包括已停止）

#### （2）查看容器资源占用
- 语法：`docker stats 容器ID/容器名`
- 输出字段：CPU 使用率、内存占用、网络 IO、磁盘 IO 等
- 退出查看：`ctrl + c`

### 5. 查看容器日志
- 语法：`docker logs [option] 容器ID/容器名`
- 常用参数：`-f` 实时跟踪日志，`--tail 100` 查看最新 100 行
- 说明：若容器未执行特殊操作，可能无日志输出

### 6. 查看容器进程
- 语法：`docker top 容器ID/容器名`
- 作用：查看容器内运行的进程信息（类似 Linux top 命令）

### 7. 进入容器
#### （1）exec 方式（推荐）
- 语法：`docker exec -it 容器ID/容器名 bash`
- 说明：进入容器后会展示目录结构，支持交互操作；退出容器不影响容器运行
- 注意：容器内默认仅包含运行必备资源，无 vi 等编辑器

#### （2）attach 方式
- 语法：`docker attach 容器ID/容器名`
- 说明：直接进入容器正在执行的终端，退出时可能导致容器停止

### 8. 容器文件复制
- 语法：`docker cp 容器ID/容器名:容器内文件路径 宿主机目标路径`
- 示例：将容器内 Nginx 首页文件复制到本地
  ```bash
  docker cp my-nginx:/usr/share/nginx/html/index.html ./
  ```
- 注意：无需容器运行，只要容器未被删除即可复制

### 9. 删除容器
- 语法：`docker rm [option] 容器ID/容器名`
- 限制：不能删除运行中的容器，需先停止（`docker stop`）或使用 `-f` 强制删除
- 强制删除所有容器（慎用）：
  ```bash
  docker rm -f $(docker ps -aq)
  ```

## 五、镜像分享（Docker Hub）
### 1. 登录 Docker Hub
- 前提：已注册 Docker Hub 账号（官网：https://hub.docker.com/，需科学上网）
- 命令：`docker login`
- 操作：输入 Docker Hub 用户名/邮箱和密码，登录成功后即可推送镜像

### 2. 推送镜像
- 步骤：
  1. 给本地镜像打标签（格式：`用户名/镜像名:tag`）
     ```bash
     docker tag nginx:latest 你的用户名/my-nginx:v1.0
     ```
  2. 推送镜像到 Docker Hub
     ```bash
     docker push 你的用户名/my-nginx:v1.0
     ```

## 六、注意事项
1. 容器操作（如 start、stop、rm）的目标只能是容器 ID 或容器名，不能直接使用镜像名；容器 ID 可只输入前几位（能唯一识别即可）
2. `docker exec` 进入容器后，修改的文件仅保存在容器内，容器删除后修改丢失，需通过 `docker commit` 保存为镜像
3. 镜像加速器配置：可解决拉取镜像慢或报错问题，需根据操作系统配置对应加速器（如阿里云、网易云加速器）

# Docker 存储和网络详解
## 一、Docker 镜像透析（核心原理）
### 1. 基础：UnionFS 联合文件系统
- **定义**：分层、轻量级、高性能的文件系统，支持将多个目录挂载到同一个虚拟文件系统，是 Docker 镜像的底层基础。
- **核心特性**：
  - 分层叠加：多个文件系统同时加载，对外呈现为单一文件系统，包含所有底层文件和目录。
  - 可继承性：基于基础镜像（无父镜像）构建各类应用镜像，实现分层继承。

### 2. 关键机制：写时复制（Copy-on-Write）
- **原理**：修改镜像时，不会直接改动原底层文件，而是复制目标文件到新层进行修改，原底层文件保持不变。
- **形象类比**：如同在预言之书中间插入新页修改内容，不影响原有篇章，新页可随时添加/移除。

### 3. 镜像工作核心逻辑
| 机制         | 说明                                                                 |
|--------------|----------------------------------------------------------------------|
| 层叠效果     | 所有独立镜像层叠加形成统一视图，用户看到完整文件系统，实际各层相互独立。 |
| 可复用性     | 不同镜像可共享底层基础镜像（如多个应用镜像共享 Ubuntu 基础层），减少冗余。 |
| 高效性体现   | 轻量（仅包含必要改动）、快速构建（新增/修改层即可，无需从头构建）、资源复用。 |

## 二、Docker 存储（数据持久化与文件共享）
### 核心问题：容器内文件修改的痛点
容器默认无 vi 等编辑器，且容器删除后内部数据/配置会丢失，需通过「目录挂载」实现数据持久化和便捷修改。

### 1. 数据卷挂载（目录挂载）
#### （1）核心概念
- **定义**：将宿主机（本地）的文件/目录映射到容器内，实现宿主机与容器的文件联动（数据共享/持久化）。
- **核心价值**：
  - 数据持久化：容器删除后，数据因存储在宿主机而不丢失。
  - 便捷修改：直接在宿主机编辑文件，修改实时同步到容器，无需进入容器操作。
- **数据卷（Volume）**：宿主机与容器目录之间的映射桥梁（虚拟目录）。

#### （2）两种挂载方式
| 挂载类型 | 语法格式                  | 关键说明                                                                 |
|----------|---------------------------|--------------------------------------------------------------------------|
| 匿名挂载 | `docker run -v 数据卷名:容器目录` | 不指定宿主机目录，默认路径：`/var/lib/docker/volumes/xxxx/_data`；支持权限控制（ro 只读/ rw 读写）。 |
| 具名挂载 | `docker run -v 宿主机目录:容器目录` | 宿主机目录必须以 `/` 开头（否则识别为数据卷）；目录与 `:` 之间无空格；宿主机不存在的目录会自动创建。 |

#### （3）具名挂载实操示例（Nginx 页面修改）
1. 基础启动（无挂载）：运行 Nginx 容器，通过宿主机 IP 可访问默认页面，但容器内无编辑器，修改困难。
   ```bash
   docker run -d --name nginx-test -p 80:80 nginx
   ```
2. 挂载启动（数据持久化）：将宿主机 `/my-nginx/html` 目录映射到容器内 Nginx 页面目录。
   ```bash
   docker run -d --name nginx-mount -p 80:80 -v /my-nginx/html:/usr/share/nginx/html nginx
   ```
3. 宿主机编辑文件：在 `/my-nginx/html` 下创建 `index.html` 并写入自定义内容（如 `<h1>Hello Docker Mount!</h1>`）。
4. 验证效果：访问宿主机 IP，页面显示自定义内容；删除容器后重新执行挂载命令，页面配置仍保留。

### 2. 制作镜像：Dockerfile
- **镜像本质**：包含应用程序、系统函数库、运行配置等文件的打包包，构建过程即文件打包过程。
- **核心用途**：将修改后的容器（如挂载配置后的 Nginx）固化为自定义镜像，便于复用和分发。
- 参考：需通过 Dockerfile 指令（如 FROM、COPY、RUN 等）编写构建脚本（官方文档可查看完整指令）。

## 三、Docker 网络（容器间通信）
### 核心目标：实现一个容器内部访问另一个容器

### 1. 方式 1：宿主机 IP + 外部端口
- **原理**：利用容器映射到宿主机的外部端口，通过宿主机 IP 实现跨容器访问。
- **工具**：`curl` 命令（命令行网络请求工具，支持 HTTP/HTTPS 协议）。
- **实操步骤**：
  1. 创建两个 Nginx 容器（app1、app2），分别映射外部端口 88、99。
     ```bash
     docker run -d --name app1 -p 88:80 nginx
     docker run -d --name app2 -p 99:80 nginx
     ```
  2. 进入 app1 容器，通过宿主机 IP + app2 外部端口访问。
     ```bash
     docker exec -it app1 bash
     curl http://宿主机IP:99
     ```
- **结果**：返回 app2 容器的 Nginx 默认页面，说明通信成功。

### 2. 方式 2：容器 IP + 内部端口
- **核心组件**：`docker0` 虚拟网络接口。
  - Docker 默认创建的桥接网络（bridge network）组件。
  - 功能：为每个容器分配唯一 IP 地址，实现容器间直接通信（无需经过宿主机端口映射）。
- **实操步骤**：
  1. 查看目标容器（如 app2）的 IP 地址。
     ```bash
     docker inspect app2  # 在输出中查找 "IPAddress" 字段（如 172.17.0.3）
     ```
  2. 进入 app1 容器，通过 app2 的容器 IP + 内部端口（Nginx 默认 80 端口）访问。
     ```bash
     docker exec -it app1 bash
     curl http://172.17.0.3:80
     ```
- **优势**：通信更直接，无需依赖宿主机端口，性能更优。

## 四、关键总结
1. **镜像层**：基于 UnionFS 分层构建，写时复制机制保证高效复用和轻量性。
2. **存储挂载**：具名挂载是生产环境常用方式，核心解决数据持久化和便捷修改问题。
3. **容器通信**：
   - 跨主机/外部访问：用「宿主机 IP + 外部端口」。
   - 同主机容器间访问：优先用「容器 IP + 内部端口」（高效直接）。
4. **实操核心**：Docker 存储和网络的设计目标是「解耦」—— 容器与数据解耦、容器与网络环境解耦，提升可移植性和灵活性。