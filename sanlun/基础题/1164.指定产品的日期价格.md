# 标题：查询2019-08-16所有产品的价格（含默认价处理）


## 一、问题背景
- 表：`Products`（`product_id`产品ID，`new_price`更改后价格，`change_date`更改日期），`(product_id, change_date)`为主键。
- 初始规则：所有产品默认价格为10。
- 需求：找出2019-08-16当天所有产品的价格（有当日前价格记录则取最新，无则用默认价10）。


## 二、示例数据
### 输入：Products表
| product_id | new_price | change_date |
|------------|-----------|-------------|
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |

### 输出
| product_id | price |
|------------|-------|
| 2          | 50    |
| 1          | 35    |
| 3          | 10    |


## 三、两种解决方案（附代码）

### 方案1：左连接 + IFNULL（覆盖所有产品）
#### 核心思路
1. 左表`t1`：取所有产品ID（去重）；
2. 右表`t2`：取2019-08-16前各产品的最新价格（`max(change_date)`找最新日期）；
3. `IFNULL`处理无记录产品，默认价10。

#### 代码
```sql
select distinct t1.product_id, ifnull(t2.new_price, 10) price
from (
    select product_id, new_price from Products  -- 所有产品ID
) t1
left join (
    select product_id, new_price 
    from Products
    where (product_id, change_date) in (
        select product_id, max(change_date)  -- 各产品最新日期
        from Products 
        where change_date <= '2019-08-16'
        group by product_id 
    )
) t2 
on t1.product_id = t2.product_id ;
```


### 方案2：UNION ALL（拆分两种场景）
#### 核心思路
1. 第一部分：取2019-08-16前各产品的最新价格；
2. 第二部分：取“所有记录都在2019-08-16后”的产品，用默认价10；
3. `UNION ALL`合并结果（无重复，效率高）。

#### 代码
```sql
-- 场景1：有2019-08-16前记录，取最新价格
select product_id, new_price price 
from Products
where (product_id, change_date) in (
    select product_id, max(change_date)
    from Products 
    where change_date <= '2019-08-16'
    group by product_id
)
union all
-- 场景2：所有记录在2019-08-16后，用默认价10
select product_id, 10 price
from Products
group by product_id
having min(change_date) > '2019-08-16';
```


## 四、关键函数/逻辑
1. `max(change_date)`：按产品分组，找截止日期前的最新价格日期；
2. `IFNULL(a, b)`：a为NULL时取b（处理默认价）；
3. `UNION ALL`：合并无重复的结果集（比`UNION`高效，无需去重）；
4. `having min(change_date) > 日期`：筛选“所有记录都在截止日期后”的产品。