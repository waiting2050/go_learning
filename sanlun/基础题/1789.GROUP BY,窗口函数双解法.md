# 标题：SQL实战-查询员工直属部门（多部门/单部门场景）


## 一、题目核心
- 员工可属多个部门，`primary_flag='Y'` 为直属部门  
- 员工仅1个部门时，默认该部门为直属（即使 `primary_flag='N'`）  


## 二、表结构
| Column Name   | Type   | 说明                     |
|---------------|--------|--------------------------|
| employee_id   | int    | 员工ID（主键之一）       |
| department_id | int    | 部门ID（主键之一）       |
| primary_flag  | varchar| 直属标记（'Y'是/'N'否）  |


## 三、示例数据
### 输入（Employee表）
| employee_id | department_id | primary_flag |
|-------------|---------------|--------------|
| 1           | 1             | N            |
| 2           | 1             | Y            |
| 2           | 2             | N            |
| 3           | 3             | N            |
| 4           | 2             | N            |
| 4           | 3             | Y            |
| 4           | 4             | N            |

### 输出（直属部门结果）
| employee_id | department_id |
|-------------|---------------|
| 1           | 1             |
| 2           | 1             |
| 3           | 3             |
| 4           | 3             |


## 四、两种解法（关键思路+代码）
### 解法1：子查询筛选（GROUP BY+IN）
#### 思路
1. 直接筛选 `primary_flag='Y'` 的直属部门  
2. 子查询找出“仅1个部门的员工ID”，匹配其部门  
```sql
select employee_id, department_id 
from Employee 
where primary_flag = 'Y' 
   or employee_id in (
       -- 子查询：统计每个员工的部门数，筛选仅1个部门的员工
       select employee_id 
       from Employee 
       group by employee_id 
       having count(*) = 1  
   );
```


### 解法2：窗口函数（OVER(PARTITION BY)）
#### 思路
1. 用窗口函数 `count(*) over (partition by employee_id)` 统计每个员工的部门总数（dept_count）  
2. 筛选“直属部门（Y）”或“仅1个部门（dept_count=1）”的记录  
```sql
select employee_id, department_id
from (
    -- 子查询：添加每个员工的部门总数列
    select *, 
           count(*) over (partition by employee_id) as dept_count  
    from Employee 
) e 
where primary_flag = 'Y' or e.dept_count = 1;
```