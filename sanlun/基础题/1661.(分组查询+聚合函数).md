# 【SQL实战】计算每台机器的平均进程耗时
## 一、需求说明
已知 `Activity` 表（机器进程活动记录），计算每台机器完成一个进程的平均耗时。  
- 单进程耗时 = 该进程的 `end` 时间戳 - `start` 时间戳；  
- 平均耗时 = 机器所有进程总耗时 ÷ 机器进程总数；  
- 结果保留 3 位小数，按 `machine_id` 分组。

## 二、表结构与示例数据
### 表结构
| 字段名 | 类型 | 说明 |
|--------|------|------|
| `machine_id` | int | 机器ID |
| `process_id` | int | 进程ID |
| `activity_type` | enum | 活动类型（`start` 进程开始，`end` 进程结束） |
| `timestamp` | float | 时间戳（单位：秒） |
| 主键 | (machine_id, process_id, activity_type) | 组合唯一，确保同一机器同一进程的开始/结束记录不重复 |

### 示例输入（完整）
`Activity` 表：
| machine_id | process_id | activity_type | timestamp |
|------------|------------|---------------|-----------|
| 0          | 0          | start         | 0.712     |
| 0          | 0          | end           | 1.520     |
| 0          | 1          | start         | 3.140     |
| 0          | 1          | end           | 4.120     |
| 1          | 0          | start         | 0.550     |
| 1          | 0          | end           | 1.550     |
| 1          | 1          | start         | 0.430     |
| 1          | 1          | end           | 1.420     |
| 2          | 0          | start         | 4.100     |
| 2          | 0          | end           | 4.512     |
| 2          | 1          | start         | 2.500     |
| 2          | 1          | end           | 5.000     |

### 示例输出
| machine_id | processing_time |
|------------|-----------------|
| 0          | 0.894           |
| 1          | 0.995           |
| 2          | 1.456           |


## 三、实现方法
### 方法1：IF函数转换时间戳 + 直接聚合
#### 核心逻辑
1. 用 `IF(activity_type='start', -1, 1) * timestamp` 转换时间戳：`start` 时间转负数，`end` 时间保留正数；  
2. 按 `machine_id` 分组后，`AVG(...)` 计算“（所有 end 时间和 - 所有 start 时间和）÷ 总记录数”；  
3. 乘以 2 是因为每个进程对应 2 条记录（`start`+`end`），最终得到“总耗时 ÷ 进程数”（平均耗时）。

#### SQL代码
```sql
SELECT 
  machine_id,
  ROUND(2 * AVG(IF(activity_type = 'start', -1, 1) * timestamp), 3) AS processing_time
FROM Activity
GROUP BY machine_id;
```


### 方法2：子查询先算单进程耗时 + 外层求平均
#### 核心逻辑
1. 子查询：按 `machine_id, process_id` 分组，`MAX(timestamp)-MIN(timestamp)` 直接获取单进程耗时（`MAX` 是 end 时间，`MIN` 是 start 时间）；  
2. 外层查询：按 `machine_id` 分组，`AVG(time)` 计算该机器所有进程的平均耗时。

#### SQL代码
```sql
SELECT 
  machine_id,
  ROUND(AVG(time), 3) AS processing_time
FROM (
  -- 子查询：计算每台机器每个进程的耗时
  SELECT 
    machine_id, 
    process_id, 
    MAX(timestamp) - MIN(timestamp) AS time
  FROM Activity
  GROUP BY machine_id, process_id
) t
GROUP BY machine_id;
```


## 四、两种方法对比
| 维度 | 方法1 | 方法2 |
|------|-------|-------|
| 逻辑复杂度 | 较高（需理解时间戳转换和乘2的意义） | 较低（分步计算，直观易理解） |
| 执行效率 | 较低（逐行处理IF函数，需遍历全表数据） | 较高（子查询提前缩小数据量，聚合计算量少） |
| 适用场景 | 数据量小、追求代码简洁 | 数据量大、注重执行效率（推荐） |