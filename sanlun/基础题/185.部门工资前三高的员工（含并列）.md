### 标题：部门工资前三高的员工（含并列）


#### 问题核心
找出每个部门中工资排名前三的员工（允许并列，如同一薪资排名相同则均保留）。


#### 测试数据
**Employee表**
| id  | name  | salary | departmentId |
|-----|-------|--------|--------------|
| 1   | Joe   | 85000  | 1            |
| 2   | Henry | 80000  | 2            |
| 3   | Sam   | 60000  | 2            |
| 4   | Max   | 90000  | 1            |
| 5   | Janet | 69000  | 1            |
| 6   | Randy | 85000  | 1            |
| 7   | Will  | 70000  | 1            |

**Department表**
| id  | name  |
|-----|-------|
| 1   | IT    |
| 2   | Sales |


#### 关键思路
1. **计算部门内薪资排名**：用 `dense_rank()` 按部门分组（`partition by departmentId`）、薪资降序排序（`order by salary desc`），相同薪资排名相同且后续排名连续。
2. **筛选前三排名**：保留排名 ≤3 的员工。
3. **关联部门名称**：通过 `departmentId` 关联 Department 表，获取部门名称。


#### 正确SQL
```sql
select 
    d.name as Department, 
    t.Employee, 
    t.Salary
from (
    select 
        departmentId,
        name as Employee,
        salary as Salary,
        dense_rank() over (
            partition by departmentId 
            order by salary desc
        ) as rk
    from Employee
) t
join Department d on t.departmentId = d.id
where t.rk <= 3;
```


#### 输出结果
| Department | Employee | Salary |
|------------|----------|--------|
| IT         | Max      | 90000  |
| IT         | Joe      | 85000  |
| IT         | Randy    | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |


#### 核心函数
- `dense_rank()`：处理并列排名，确保相同薪资同排名，后续排名连续（如 1,1,2），适合“前三高”含并列的场景。